from fastapi import APIRouter, status, Depends, Body, HTTPException, UploadFile, File
from fastapi.security import OAuth2PasswordRequestForm

from apps.accounts import schemas
from apps.accounts.services.authenticate import AccountService
from apps.accounts.services.permissions import Permission
from apps.accounts.services.user import User, UserManager
from apps.core.cloudinary_service import CloudinaryService

router = APIRouter(
    prefix='/accounts'
)


# ------------------------
# --- Register Routers ---
# ------------------------


@router.post(
    '/register',
    status_code=status.HTTP_201_CREATED,
    response_model=schemas.RegisterOut,
    summary='Register a new user',
    description="""## Register a new user by email and password, then send an OTP code to the user's email address.
    
Generate an account activation code for a user whose account is not yet enabled.

The account activation code generated by this endpoint is designed for one-time use and will expire after 5 minutes. 
If a new POST request is made to this endpoint, a new code will be generated if the previous code has expired. The newly
 generated code will be valid for another 5 minutes, while the previous code will no longer be valid.

Following the registration request, this endpoint will send an OTP code to the user's email address. It is essential to 
verify this OTP code using the `/accounts/register/verify` endpoint. Verification confirms the user's email address and 
activates their account.
 
Please note that users cannot log in to their accounts until their email addresses are verified.
""",
    tags=['Authentication'])
async def register(payload: schemas.RegisterIn = Body(**schemas.RegisterIn.examples())):
    return AccountService.register(**payload.model_dump(exclude={"password_confirm"}))


@router.patch(
    '/register/verify',
    status_code=status.HTTP_200_OK,
    response_model=schemas.RegisterVerifyOut,
    summary='Verify user registration',
    description='Verify a new user registration by confirming the provided OTP.',
    tags=['Authentication'])
async def verify_registration(payload: schemas.RegisterVerifyIn):
    return AccountService.verify_registration(**payload.model_dump())


# ---------------------
# --- Login Routers ---
# ---------------------


@router.post(
    '/login',
    status_code=status.HTTP_200_OK,
    response_model=schemas.LoginOut,
    summary='Login a user',
    description='Login a user with valid credentials, if user account is active.',
    tags=['Authentication'])
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    return AccountService.login(form_data.username, form_data.password)


@router.post(
    '/logout',
    status_code=status.HTTP_204_NO_CONTENT,
    summary='Logout user',
    description="Logout the currently authenticated user. "
                "Revokes the user's access token and invalidates the session.",
    tags=['Authentication'])
async def logout(current_user: User = Depends(AccountService.current_user)):
    AccountService.logout(current_user)


# ------------------------
# --- Password Routers ---
# ------------------------


@router.post(
    '/reset-password',
    status_code=status.HTTP_200_OK,
    response_model=schemas.PasswordResetOut,
    summary='Reset password',
    description="Initiate a password reset request by sending a verification email to the user's "
                "registered email address.",
    tags=['Authentication'])
async def reset_password(payload: schemas.PasswordResetIn):
    return AccountService.reset_password(**payload.model_dump())


@router.patch(
    '/reset-password/verify',
    status_code=status.HTTP_200_OK,
    response_model=schemas.PasswordResetVerifyOut,
    summary='Verify reset password',
    description="Verify the password reset request by confirming the provided OTP sent to the user's "
                "registered email address. If the change is successful, the user will need to login again.",
    tags=['Authentication'])
async def verify_reset_password(payload: schemas.PasswordResetVerifyIn):
    return AccountService.verify_reset_password(**payload.model_dump(exclude={"password_confirm"}))


# -------------------
# --- OTP Routers ---
# -------------------


@router.post(
    '/otp',
    status_code=status.HTTP_204_NO_CONTENT,
    summary='Resend OTP',
    description="""Allows the user to request a new OTP (One-Time Password) for registration, password reset,
    or email change verification.

### Usage Guidelines:
- For **registration** and **password reset**, provide the user's **primary email address**.
- For **email change**, provide the **primary email address** too, (not the new unverified email).
    """,

    tags=['Authentication'])
async def resend_otp(payload: schemas.OTPResendIn = Body(**schemas.OTPResendIn.examples())):
    AccountService.resend_otp(**payload.model_dump())


# ---------------------
# --- Users Routers ---
# ---------------------


@router.get(
    '/me',
    status_code=status.HTTP_200_OK,
    response_model=schemas.CurrentUserOut,
    summary='Retrieve current user',
    description='Retrieve current user if user is active.',
    tags=['Users'])
async def retrieve_me(current_user: User = Depends(AccountService.current_user)):
    return {'user': UserManager.to_dict(current_user)}


@router.put(
    '/me',
    status_code=status.HTTP_200_OK,
    response_model=schemas.CurrentUserOut,
    summary='Update current user',
    description='Update current user.',
    tags=['Users'])
async def update_me(payload: schemas.UpdateUserIn, current_user: User = Depends(AccountService.current_user)):
    user = UserManager.update_user(current_user.id, **payload.user.model_dump())
    return {'user': UserManager.to_dict(user)}


@router.post(
    '/me/upload-image',
    status_code=status.HTTP_200_OK,
    response_model=schemas.CurrentUserOut,
    summary='Upload profile image',
    description='Upload a profile image for the current user.',
    tags=['Users'])
async def upload_profile_image(
    file: UploadFile = File(...),
    current_user: User = Depends(AccountService.current_user)
):
    """Upload profile image to Cloudinary and update user profile"""
    # Upload to Cloudinary (async call)
    result = await CloudinaryService.upload_image(file, folder="prephub/profiles")
    
    # Get user ID (handle both User object and dict)
    user_id = current_user.id if isinstance(current_user, User) else current_user['id']
    
    # Update user with image URL
    user = UserManager.update_user(user_id, profile_image=result['url'])
    return {'user': UserManager.to_dict(user)}


@router.patch(
    '/me/password',
    status_code=status.HTTP_200_OK,
    response_model=schemas.PasswordChangeOut,
    summary='Change current user password',
    description='Change the password for the current user. If the change is successful, the user will '
                'need to login again.',
    tags=['Users'])
async def change_password(payload: schemas.PasswordChangeIn = Body(**schemas.PasswordChangeIn.examples()),
                          current_user: User = Depends(AccountService.current_user)):
    return AccountService.change_password(current_user, **payload.model_dump(exclude={"password_confirm"}))


@router.post(
    '/me/email',
    status_code=status.HTTP_200_OK,
    response_model=schemas.EmailChangeOut,
    summary='Change current user email',
    description="""## Change the email address for the current user.

After the new email is set, an OTP code will be sent to the new email address for verification purposes.
""",
    tags=['Users'])
async def change_email(email: schemas.EmailChangeIn, current_user: User = Depends(AccountService.current_user)):
    return AccountService.change_email(current_user, **email.model_dump())


@router.patch(
    '/me/email/verify',
    status_code=status.HTTP_200_OK,
    response_model=schemas.EmailChangeVerifyOut,
    summary='Verify change current user email',
    description="""## Verify the email address change for the current user.

Validating the OTP code sent to the user's new email address. If the OTP is valid, the new
email address will be saved as the user's main email address.
""",
    tags=['Users'])
async def verify_change_email(otp: schemas.EmailChangeVerifyIn,
                              current_user: User = Depends(AccountService.current_user)):
    return AccountService.verify_change_email(current_user, **otp.model_dump())


@router.get(
    '/{user_id}',
    status_code=status.HTTP_200_OK,
    response_model=schemas.CurrentUserOut,
    summary='Retrieve a single user',
    description='Retrieve a single user by ID. Only admins can read the users data.',
    tags=['Users'],
    dependencies=[Depends(Permission.is_admin)]
)
async def retrieve_user(user_id: int):
    user = UserManager.get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return {'user': UserManager.to_dict(user)}

# -----------------------
# --- Admin Endpoints ---
# -----------------------

@router.get(
    '/admin/users',
    status_code=status.HTTP_200_OK,
    response_model=schemas.UsersListOut,
    summary='List all users',
    description='List all users in the system. Only admins can access this.',
    tags=['Admin'],
    dependencies=[Depends(Permission.is_admin)]
)
async def list_all_users(skip: int = 0, limit: int = 100):
    users = UserManager.list_users(skip=skip, limit=limit)
    return {"users": [schemas.UserListItem.from_user(u) for u in users], "total": len(users)}


@router.patch(
    '/admin/users/{user_id}/role',
    status_code=status.HTTP_200_OK,
    response_model=schemas.UpdateUserRoleOut,
    summary='Update user role',
    description='Update a user\'s role. Only admins can do this. Valid roles: user, hostel, coaching, library, tiffin, admin',
    tags=['Admin'],
    dependencies=[Depends(Permission.is_admin)]
)
async def update_user_role(user_id: int, payload: schemas.UpdateUserRoleIn):
    user = UserManager.get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    UserManager.update_user(user_id, role=payload.role)
    updated_user = UserManager.get_user_by_id(user_id)
    
    return {
        "id": updated_user.id,
        "email": updated_user.email,
        "role": updated_user.role,
        "message": f"User role updated to {payload.role}"
    }


@router.post(
    '/admin/users/{user_id}/approve-lister',
    status_code=status.HTTP_200_OK,
    response_model=schemas.ApproveListerOut,
    summary='Approve/reject listing owner',
    description='Admin approves or rejects a user to create listings',
    tags=['Admin'],
    dependencies=[Depends(Permission.is_admin)]
)
async def approve_lister(user_id: int, payload: schemas.ApproveListerIn):
    user = UserManager.get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Only approve users with listing roles
    if user.role not in ['hostel', 'coaching', 'library', 'tiffin']:
        raise HTTPException(status_code=400, detail="User must have a listing role (hostel, coaching, library, tiffin)")
    
    UserManager.update_user(user_id, is_approved_lister=payload.approve)
    updated_user = UserManager.get_user_by_id(user_id)
    
    return {
        "message": f"User {'approved' if payload.approve else 'rejected'} as lister",
        "user": schemas.UserListItem.from_user(updated_user)
    }


@router.delete(
    '/admin/users/{user_id}',
    status_code=status.HTTP_200_OK,
    response_model=schemas.DeleteUserOut,
    summary='Delete user account',
    description='Admin can delete any user account',
    tags=['Admin'],
    dependencies=[Depends(Permission.is_admin)]
)
async def delete_user_account(user_id: int):
    user = UserManager.get_user_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Delete user
    from config.database import SessionLocal
    db = SessionLocal()
    try:
        db.delete(user)
        db.commit()
        return {"message": f"User {user.email} deleted successfully"}
    finally:
        db.close()


@router.get(
    '/admin/users/{user_id}/details',
    status_code=status.HTTP_200_OK,
    response_model=schemas.UserDetailOut,
    summary='Get user details with enrollments',
    description='Get detailed user information including all bookings and stats. Admin only.',
    tags=['Admin'],
    dependencies=[Depends(Permission.is_admin)]
)
async def get_user_details(user_id: int):
    from config.database import SessionLocal
    from apps.bookings.models import Booking
    from apps.listings.models import Listing
    from apps.core.date_time import DateTime
    
    db = SessionLocal()
    try:
        user = UserManager.get_user_by_id(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        # Get all bookings for this user
        bookings = db.query(Booking).filter(Booking.user_id == user_id).all()
        
        # Calculate stats
        stats = schemas.UserStats(
            total_bookings=len(bookings),
            pending_bookings=sum(1 for b in bookings if b.status == 'pending'),
            accepted_bookings=sum(1 for b in bookings if b.status == 'accepted'),
            rejected_bookings=sum(1 for b in bookings if b.status == 'rejected'),
            total_spent=sum(float(b.amount) for b in bookings if b.status == 'accepted')
        )
        
        # Format bookings with listing info
        booking_info = []
        for booking in bookings:
            listing = db.query(Listing).filter(Listing.id == booking.listing_id).first()
            booking_info.append(schemas.UserBookingInfo(
                id=booking.id,
                listing_id=booking.listing_id,
                listing_name=listing.name if listing else "Unknown",
                listing_type=listing.type if listing else "Unknown",
                status=booking.status,
                amount=float(booking.amount),
                payment_id=booking.payment_id,
                enrolled_at=DateTime.string(booking.created_at)
            ))
        
        return schemas.UserDetailOut(
            id=user.id,
            email=user.email,
            first_name=user.first_name,
            last_name=user.last_name,
            phone_number=user.phone_number,
            address=user.address,
            city=user.city,
            state=user.state,
            pincode=user.pincode,
            role=user.role,
            is_active=user.is_active,
            is_verified_email=user.is_verified_email,
            is_superuser=user.is_superuser,
            is_approved_lister=user.is_approved_lister,
            date_joined=DateTime.string(user.date_joined),
            last_login=DateTime.string(user.last_login) if user.last_login else None,
            stats=stats,
            bookings=booking_info
        )
    finally:
        db.close()


# TODO DELETE /accounts/me
# TODO add docs and examples to endpoints
